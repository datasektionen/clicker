<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Count Me Inn - Client (Real-time)</title>
    <style>
        /* ... (CSS remains the same) ... */
         body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f5f5;
        }
        h1, h2 {
            color: #333;
        }
        .event-container {
            background-color: white;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 20px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .counter-container {
            display: flex;
            align-items: center;
            margin: 10px 0;
            padding: 10px;
            background-color: #f9f9f9;
            border-radius: 4px;
        }
        .counter-name {
            flex: 1;
            font-weight: bold;
        }
        .counter-value {
            font-size: 24px;
            margin: 0 15px;
            min-width: 40px;
            text-align: center;
        }
        button {
            background-color: #4CAF50;
            color: white;
            border: none;
            padding: 8px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 16px;
            margin: 0 2px;
            transition: background-color 0.2s ease;
        }
        button:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
        }
        button:hover:not(:disabled) {
            background-color: #45a049;
        }
        button.remove {
            background-color: #f44336;
        }
        button.remove:hover:not(:disabled) {
            background-color: #d32f2f;
        }
        button.minus {
            background-color: #ff9800;
        }
        button.minus:hover:not(:disabled) {
            background-color: #fb8c00;
        }
        .add-form {
            margin: 15px 0;
            display: flex;
            gap: 10px;
        }
        input {
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            flex: 1;
        }
        .status {
            color: #666;
            font-style: italic;
            margin-top: 20px;
            min-height: 1.2em; /* Prevent layout shifts */
        }
        .no-events {
            text-align: center;
            padding: 30px;
            color: #666;
        }
        .connection-status {
            position: fixed;
            top: 10px;
            right: 10px;
            padding: 5px 10px;
            border-radius: 20px;
            font-size: 12px;
            font-weight: bold;
            transition: background-color 0.3s ease, color 0.3s ease;
        }
        .connected {
            background-color: #c8e6c9;
            color: #2e7d32;
        }
        .disconnected {
            background-color: #ffcdd2;
            color: #c62828;
        }
        .connecting { /* Added style for connecting state */
             background-color: #fff9c4; /* Light yellow */
             color: #f57f17;    /* Amber */
        }
        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(255, 255, 255, 0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 1.5em;
            color: #333;
            z-index: 1000; /* Ensure it's on top */
             visibility: hidden; /* Hide by default */
             opacity: 0;
             transition: opacity 0.3s ease, visibility 0s 0.3s;
        }
         .loading-overlay.show {
             visibility: visible;
             opacity: 1;
             transition: opacity 0.3s ease;
         }
    </style>
</head>
<body>
    <!-- Initial state is connecting -->
    <div class="connection-status connecting" id="connectionStatus">Connecting...</div>
    <div class="loading-overlay" id="loadingOverlay">Loading...</div>

    <h1>Count Me Inn</h1>

    <div class="add-form">
        <input type="text" id="newEventName" placeholder="Enter event name..." disabled>
        <button onclick="addEvent()" id="addEventBtn" disabled>Create New Event</button>
    </div>

    <div id="eventsContainer">
        <div class="no-events" id="noEventsMessage">Connecting to server...</div>
    </div>

    <div class="status" id="statusMessage"></div>

    <script>
        const API_URL = 'http://localhost:3000/api'; // Your backend API base URL
        let events = [];
        const eventsContainer = document.getElementById('eventsContainer');
        const noEventsMessage = document.getElementById('noEventsMessage');
        const statusMessage = document.getElementById('statusMessage');
        const connectionStatus = document.getElementById('connectionStatus');
        const loadingOverlay = document.getElementById('loadingOverlay');
        const newEventNameInput = document.getElementById('newEventName');
        const addEventBtn = document.getElementById('addEventBtn');

        let sseSource = null; // To hold the EventSource object
        let isSseConnected = false; // Track SSE connection specifically
        let debounceTimer = null;

        // --- Loading Indicator ---
        function showLoading(show) {
            if (show) {
                loadingOverlay.classList.add('show');
            } else {
                loadingOverlay.classList.remove('show');
            }
        }


        // --- API Helper (No changes needed) ---
        async function apiRequest(endpoint, method = 'GET', body = null) {
            const options = {
                method,
                headers: {
                    'Content-Type': 'application/json',
                },
            };
            if (body) {
                options.body = JSON.stringify(body);
            }

            // Show loading only for actions initiated by the user (POST, PATCH, DELETE)
            // GET is usually in the background or initial load.
            const showLoader = ['POST', 'PATCH', 'DELETE'].includes(method.toUpperCase());
            if (showLoader) showLoading(true);


            try {
                const response = await fetch(`${API_URL}${endpoint}`, options);
                 // Don't update connection status here solely based on API calls, rely on SSE status
                // setConnectionStatus(true); // REMOVED

                if (!response.ok) {
                    const errorData = await response.json().catch(() => ({ message: 'Unknown server error' }));
                    throw new Error(`API Error (${response.status}): ${errorData.message || response.statusText}`);
                }

                if (response.status === 204) {
                    return null;
                }
                return await response.json();

            } catch (error) {
                console.error(`API Request Failed: ${method} ${endpoint}`, error);
                // Don't update connection status here either
                // setConnectionStatus(false); // REMOVED
                showStatus(`Error: ${error.message}`, true);
                throw error;
            } finally {
                 if (showLoader) showLoading(false);
            }
        }

        // --- Connection Status (Updated for SSE) ---
        function updateUiForConnectionState(connected) {
            // Enable/disable interaction based on SSE connection
            const allButtons = document.querySelectorAll('button');
            const allInputs = document.querySelectorAll('input');
            allButtons.forEach(btn => btn.disabled = !connected);
            allInputs.forEach(input => input.disabled = !connected);
            // Special case for the connection indicator itself
            connectionStatus.disabled = false;
        }

        function setConnectionStatus(status, message) {
             // status can be 'connecting', 'connected', 'disconnected'
             connectionStatus.textContent = message;
             connectionStatus.className = "connection-status " + status; // Use status directly as class

             isSseConnected = (status === 'connected');
             updateUiForConnectionState(isSseConnected);

              // Update placeholder text based on connection
              if (isSseConnected && events.length === 0) {
                 noEventsMessage.textContent = 'No events created yet. Add one above!';
                 noEventsMessage.style.display = 'block';
              } else if (!isSseConnected && status !== 'connecting') {
                 noEventsMessage.textContent = 'Connection lost. Attempting to reconnect...';
                  noEventsMessage.style.display = events.length === 0 ? 'block' : 'none'; // Show if no events loaded
              } else if (status === 'connecting') {
                  noEventsMessage.textContent = 'Connecting to server...';
                  noEventsMessage.style.display = 'block'; // Always show when connecting initially
              }
        }

        // --- Status Messages (No changes needed) ---
        function showStatus(message, isError = false) {
             clearTimeout(debounceTimer);
            statusMessage.textContent = message;
            statusMessage.style.color = isError ? '#c62828' : '#666';

             if (!isError || message.startsWith("Connected")) {
                 debounceTimer = setTimeout(() => {
                    if (statusMessage.textContent === message) {
                         statusMessage.textContent = "";
                    }
                }, 4000);
            }
        }


         // --- SSE Event Handling ---
        function handleSseMessage(event) { // In index.html
            try {
                const data = JSON.parse(event.data);
                console.log("SSE Received (Main View):", data);
                const payload = data.payload;
                let needsRender = false;

                // Find the target event in the global 'events' array
                let targetEvent, targetEventIndex;
                const eventIdToFind = payload.event_id ?? payload.eventId ?? payload.id; // Find relevant event ID

                if (eventIdToFind) {
                    targetEventIndex = events.findIndex(e => e.id === eventIdToFind);
                    targetEvent = events[targetEventIndex];
                }


                switch (data.type) {
                    case 'event_added':
                        if (!events.some(e => e.id === payload.id)) {
                            events.push(payload); // Add the new event object
                            needsRender = true;
                        }
                        break;
                    case 'event_removed':
                        const initialLength = events.length;
                        events = events.filter(e => e.id !== payload.eventId);
                        if (events.length < initialLength) {
                            needsRender = true;
                        }
                        break;
                    case 'event_updated': // e.g., name change
                        if (targetEvent) {
                            // Merge updates into the event object
                            events[targetEventIndex] = { ...targetEvent, ...payload };
                            needsRender = true;
                        }
                        break;

                    case 'counter_added':
                        if (targetEvent) {
                            targetEvent.counters = targetEvent.counters || [];
                            if (!targetEvent.counters.some(c => c.id === payload.id)) {
                                targetEvent.counters.push(payload);
                                needsRender = true;
                            }
                        }
                        break;
                    case 'counter_removed':
                        if (targetEvent && targetEvent.counters) {
                            const initialCounterLength = targetEvent.counters.length;
                            targetEvent.counters = targetEvent.counters.filter(c => c.id !== payload.counterId);
                            if (targetEvent.counters.length < initialCounterLength) {
                                needsRender = true;
                            }
                        }
                        break;
                    case 'counter_updated':
                        if (targetEvent && targetEvent.counters) {
                            const counterIndex = targetEvent.counters.findIndex(c => c.id === payload.id);
                            if (counterIndex > -1) {
                                // Update the specific counter within the event
                                targetEvent.counters[counterIndex] = { ...targetEvent.counters[counterIndex], ...payload };
                                needsRender = true;
                            }
                        }
                        break;
                    case 'connected':
                        console.log(`SSE Connected with Client ID: ${payload?.clientId}`);
                        // Load initial data via loadEvents() if needed (handled in init/onopen)
                        break;
                    case 'error':
                        showStatus(`Server Error: ${payload.message}`, true);
                        break;
                    // ... other cases ...
                }

                if (needsRender) {
                    console.log("Calling renderEvents due to state change.");
                    renderEvents(); // Re-render the entire list on the main page
                }

            } catch (error) {
                console.error("Error parsing or handling SSE data (Main View):", error, "Raw data:", event.data);
                showStatus("Received invalid update from server.", true);
            }
        }

        function connectSSE() {
            if (sseSource && sseSource.readyState !== EventSource.CLOSED) {
                console.log("SSE connection already open or connecting.");
                return;
            }

            setConnectionStatus('connecting', 'Connecting...');
            sseSource = new EventSource(`${API_URL}/events/stream`);

            sseSource.onopen = () => {
                console.log("SSE Connection Opened");
                setConnectionStatus('connected', 'Connected');
                 showStatus("Real-time updates enabled.");
                // Load initial data *after* connection is confirmed open
                loadEvents();
            };

            sseSource.onmessage = handleSseMessage;

            sseSource.onerror = (error) => {
                console.error("SSE Error:", error);
                setConnectionStatus('disconnected', 'Disconnected');
                showStatus("Connection error. Trying to reconnect...", true);
                // EventSource handles automatic reconnection by default.
                // We just update the UI state.
                sseSource.close(); // Close the potentially broken source before it retries internally
                // Optionally add a delay before explicit reconnect attempt if EventSource retry fails
                 setTimeout(connectSSE, 5000); // Try reconnecting explicitly after 5 seconds
            };
        }


        // --- Core Logic (Modified to use apiRequest, SSE updates handle state changes) ---
        async function loadEvents() {
            // showLoading(true); // Show loading for initial fetch
            try {
                const fetchedEvents = await apiRequest('/events');
                events = fetchedEvents.map(event => ({
                    ...event,
                    counters: event.counters || []
                }));
                renderEvents(); // Render initial state
                showStatus("Events loaded.");
            } catch (error) {
                 showStatus("Failed to load initial events.", true);
                 renderEvents(); // Render to show empty state message
            } finally {
                 // showLoading(false);
            }
        }

        // Actions just call the API. State updates are handled by SSE listener.
        async function addEvent() {
             const newEventName = newEventNameInput.value.trim();
             if (!newEventName) {
                 showStatus("Event name cannot be empty.", true);
                 return;
             }
             try {
                 // API call triggers broadcast on success
                 await apiRequest('/events', 'POST', { name: newEventName });
                 newEventNameInput.value = ''; // Clear input on successful request initiation
                 // showStatus(`Event "${newEventName}" creation requested.`); // Optimistic message
                 // Actual update comes via SSE
             } catch (error) {
                 // Error already shown by apiRequest
             }
        }

        async function removeEvent(eventId) {
             if (!confirm("Are you sure you want to remove this event?")) return;
             try {
                 await apiRequest(`/events/${eventId}`, 'DELETE');
                 // showStatus(`Event removal requested.`);
             } catch (error) {}
        }

        async function addCounter(eventId) {
             const counterName = prompt("Enter new counter name:", "New Counter");
             if (!counterName || !counterName.trim()) {
                 showStatus("Counter name cannot be empty.", true);
                 return;
             }
             try {
                 await apiRequest(`/events/${eventId}/counters`, 'POST', { name: counterName.trim() });
                 // showStatus(`Counter addition requested.`);
             } catch (error) {}
        }

        async function removeCounter(eventId, counterId) {
              const event = events.find(e => e.id === eventId);
              if (event && event.counters.length <= 1) {
                  alert("Cannot remove the last counter.");
                  return;
              }
              if (!confirm("Are you sure you want to remove this counter?")) return;
              try {
                  await apiRequest(`/events/${eventId}/counters/${counterId}`, 'DELETE');
                 // showStatus(`Counter removal requested.`);
              } catch (error) {}
        }

        async function updateCount(eventId, counterId, change) {
             // No optimistic update needed here, SSE will provide the confirmed state.
             // Prevent sending update if trying to decrement below zero.
             const event = events.find(e => e.id === eventId);
             const counter = event?.counters.find(c => c.id === counterId);
             if (change < 0 && (!counter || counter.count <= 0)) {
                console.log("Attempted to decrement below zero. Ignoring.");
                 return;
             }

             try {
                 await apiRequest(`/events/${eventId}/counters/${counterId}`, 'PATCH', { change });
                 // showStatus(`Count update requested.`);
             } catch (error) {}
        }

        // --- Rendering (No significant changes needed, but ensure IDs are correct) ---
        function calculateEventTotal(event) {
            if (!event || !Array.isArray(event.counters)) return 0;
            return event.counters.reduce((sum, counter) => sum + (counter.count || 0), 0);
        }

// --- Rendering (index.html) ---

     // Helper function (should exist elsewhere in your script)
     function calculateEventTotal(event) {
         if (!event || !Array.isArray(event.counters)) return 0;
         return event.counters.reduce((sum, counter) => sum + (counter.count || 0), 0);
     }

     function renderEvents() {
         console.log("Rendering events on main page:", events); // Debug log

         // Get references to containers (assuming these are defined globally in the script)
         // const eventsContainer = document.getElementById('eventsContainer');
         // const noEventsMessage = document.getElementById('noEventsMessage');
         // let isSseConnected = ...; // Assumes this variable is updated elsewhere

         if (!events || events.length === 0) {
             // Message content is handled by setConnectionStatus, just control visibility
             if (isSseConnected) {
                noEventsMessage.textContent = 'No events created yet. Add one above!';
             } // The 'connecting' or 'disconnected' messages are handled elsewhere
             noEventsMessage.style.display = 'block';
             eventsContainer.innerHTML = ''; // Clear any previous events
             // Ensure the message element is inside the container if it wasn't already
             if (!eventsContainer.contains(noEventsMessage)) {
                  eventsContainer.appendChild(noEventsMessage);
             }
             return;
         }

         // If we have events, hide the 'no events' message and clear the container
         noEventsMessage.style.display = 'none';
         eventsContainer.innerHTML = '';

         // Optional: Sort events alphabetically by name
         const sortedEvents = [...events].sort((a, b) => a.name.localeCompare(b.name));

         sortedEvents.forEach(event => {
             const eventDiv = document.createElement('div');
             eventDiv.className = 'event-container';
             eventDiv.dataset.eventId = event.id; // Store event ID for reference

             const eventTotal = calculateEventTotal(event);

             // --- Event Header ---
             const eventHeader = document.createElement('div');
             eventHeader.style.display = 'flex';
             eventHeader.style.justifyContent = 'space-between';
             eventHeader.style.alignItems = 'flex-start'; // Align items to the top for better wrapping
             eventHeader.style.marginBottom = '10px';
             eventHeader.style.flexWrap = 'wrap'; // Allow wrapping on smaller screens

             // --- Title and Total (Left Side) ---
             const titleAndTotalDiv = document.createElement('div');
             titleAndTotalDiv.style.flexGrow = '1'; // Allow this section to grow
             titleAndTotalDiv.style.marginRight = '10px'; // Space before buttons

             const eventTitle = document.createElement('h2');
             eventTitle.textContent = event.name;
             eventTitle.style.marginBottom = '5px';
             eventTitle.style.marginTop = '0'; // Remove default margin
             titleAndTotalDiv.appendChild(eventTitle);

             const totalDiv = document.createElement('div');
             totalDiv.style.fontSize = '18px';
             totalDiv.innerHTML = `Total Attendance: <strong>${eventTotal}</strong>`;
             titleAndTotalDiv.appendChild(totalDiv);

             eventHeader.appendChild(titleAndTotalDiv);

             // --- Action Buttons (Right Side) ---
             const eventActionsDiv = document.createElement('div');
             eventActionsDiv.style.display = 'flex';
             eventActionsDiv.style.gap = '5px'; // Space between buttons
             eventActionsDiv.style.alignItems = 'center'; // Vertically align buttons
             eventActionsDiv.style.flexShrink = '0'; // Prevent buttons from shrinking too much


             // 'Open Counter View' Button
             const openViewBtn = document.createElement('button');
             openViewBtn.textContent = 'Open Counter View';
             openViewBtn.title = 'Open simplified counter view in new tab';
             // openViewBtn.style.marginRight = '5px'; // Use gap instead
             openViewBtn.disabled = !isSseConnected; // Disable if not connected
             openViewBtn.onclick = () => {
                 // Open event.html in a new tab, passing the event ID
                 window.open(`event.html?eventId=${event.id}`, `_blank`);
             };
             eventActionsDiv.appendChild(openViewBtn);

             // 'Remove Event' Button
             const removeEventBtn = document.createElement('button');
             removeEventBtn.className = 'remove';
             removeEventBtn.textContent = 'Remove Event';
             removeEventBtn.disabled = !isSseConnected; // Disable if not connected
             removeEventBtn.onclick = () => removeEvent(event.id); // Assumes removeEvent function exists
             eventActionsDiv.appendChild(removeEventBtn);

             eventHeader.appendChild(eventActionsDiv);
             eventDiv.appendChild(eventHeader);

             // --- Separator ---
             const separator = document.createElement('hr');
             separator.style.border = 'none';
             separator.style.borderTop = '1px solid #eee';
             separator.style.margin = '15px 0';
             eventDiv.appendChild(separator);

             // --- Counters List ---
             // Optional: Sort counters alphabetically by name
             const sortedCounters = event.counters ? [...event.counters].sort((a, b) => a.name.localeCompare(b.name)) : [];

             if (sortedCounters.length > 0) {
                 sortedCounters.forEach(counter => {
                     const counterDiv = document.createElement('div');
                     counterDiv.className = 'counter-container';
                     counterDiv.dataset.counterId = counter.id; // Store counter ID

                     const nameDiv = document.createElement('div');
                     nameDiv.className = 'counter-name';
                     nameDiv.textContent = counter.name;
                     counterDiv.appendChild(nameDiv);

                     const valueDiv = document.createElement('div');
                     valueDiv.className = 'counter-value';
                     valueDiv.textContent = counter.count ?? 0; // Handle null/undefined counts
                     counterDiv.appendChild(valueDiv);

                     // Minus Button
                     const minusBtn = document.createElement('button');
                     minusBtn.className = 'minus';
                     minusBtn.textContent = '-';
                     minusBtn.disabled = !isSseConnected || (counter.count ?? 0) <= 0;
                     minusBtn.onclick = () => updateCount(event.id, counter.id, -1); // Assumes updateCount exists
                     counterDiv.appendChild(minusBtn);

                     // Plus Button
                     const plusBtn = document.createElement('button');
                     plusBtn.textContent = '+';
                     plusBtn.disabled = !isSseConnected;
                     plusBtn.onclick = () => updateCount(event.id, counter.id, 1); // Assumes updateCount exists
                     counterDiv.appendChild(plusBtn);

                     // Remove Counter Button
                     const canRemoveCounter = isSseConnected && (!event.counters || event.counters.length > 1);
                     const removeCounterBtn = document.createElement('button');
                     removeCounterBtn.className = 'remove';
                     removeCounterBtn.textContent = '×'; // Multiplication sign for 'remove'
                     removeCounterBtn.disabled = !canRemoveCounter;
                     removeCounterBtn.title = canRemoveCounter ? "Remove counter" : "Cannot remove the last counter";
                     removeCounterBtn.onclick = () => removeCounter(event.id, counter.id); // Assumes removeCounter exists
                     counterDiv.appendChild(removeCounterBtn);

                     eventDiv.appendChild(counterDiv);
                 });
             } else {
                 // Optional: Message if an event has no counters
                 const noCountersMsg = document.createElement('p');
                 noCountersMsg.textContent = 'No counters added to this event yet.';
                 noCountersMsg.style.color = '#666';
                 noCountersMsg.style.fontStyle = 'italic';
                 noCountersMsg.style.textAlign = 'center';
                 noCountersMsg.style.padding = '10px 0';
                 eventDiv.appendChild(noCountersMsg);
             }


             // --- Add Counter Button ---
             const addCounterDiv = document.createElement('div');
             addCounterDiv.style.marginTop = '15px'; // More space before add button
             addCounterDiv.style.textAlign = 'right'; // Align button to the right

             const addCounterBtn = document.createElement('button');
             addCounterBtn.textContent = 'Add Counter';
             addCounterBtn.disabled = !isSseConnected;
             addCounterBtn.onclick = () => addCounter(event.id); // Assumes addCounter function exists
             addCounterDiv.appendChild(addCounterBtn);
             eventDiv.appendChild(addCounterDiv);

             // --- Append the fully built event card to the main container ---
             eventsContainer.appendChild(eventDiv);
         });

         // Ensure UI reflects connection state after rendering all elements
         updateUiForConnectionState(isSseConnected); // Assumes updateUiForConnectionState exists
     }

        // --- Initialization ---
        function init() {
            // Initial UI state
            setConnectionStatus('connecting', 'Connecting...'); // Show connecting initially
            renderEvents(); // Render empty state initially


            // Make Enter key work for adding events
            newEventNameInput.addEventListener('keypress', function(e) {
                if (e.key === 'Enter' && !addEventBtn.disabled) {
                    addEvent();
                }
            });

            // Start the SSE connection process
            connectSSE();

            // No need for the setInterval check anymore, SSE handles connection status
        }

        // Start the application
        init();

    </script>
</body>
</html>